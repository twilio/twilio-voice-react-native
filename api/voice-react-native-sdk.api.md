## API Report File for "@twilio/voice-react-native-sdk"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { EventEmitter } from 'eventemitter3';

// @public (undocumented)
type AudioCodec = OpusAudioCodec | PCMUAudioCodec;

// @public
export class AudioDevice {
    // Warning: (ae-forgotten-export) The symbol "NativeAudioDeviceInfo" needs to be exported by the entry point index.d.ts
    //
    // @internal
    constructor({ uuid, type, name }: NativeAudioDeviceInfo);
    name: string;
    select(): Promise<void>;
    type: AudioDevice.Type;
    // Warning: (ae-forgotten-export) The symbol "Uuid" needs to be exported by the entry point index.d.ts
    //
    // @internal
    uuid: Uuid;
}

// @public
export namespace AudioDevice {
    export enum Type {
        // (undocumented)
        Bluetooth = "bluetooth",
        // (undocumented)
        Earpiece = "earpiece",
        // (undocumented)
        Speaker = "speaker"
    }
}

// @public
namespace AuthorizationErrors {
    class AccessTokenExpired extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class AccessTokenGrantsInvalid extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class AccessTokenHeaderInvalid extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class AccessTokenInvalid extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class AccessTokenIssuerInvalid extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class AccessTokenNotYetValid extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class AccessTokenRejected extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class AccessTokenSignatureInvalid extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class AuthenticationFailed extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class AuthorizationError extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class CallMessageEventTypeInvalidError extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class CallMessageUnexpectedStateError extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class ExpirationTimeExceedsMaxTimeAllowed extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class PayloadSizeExceededError extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class RateExceededError extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
}

// @public
export interface Call {
    addListener(connectedEvent: Call.Event.Connected, listener: Call.Listener.Connected): this;
    addListener(connectFailureEvent: Call.Event.ConnectFailure, listener: Call.Listener.ConnectFailure): this;
    addListener(reconnectingEvent: Call.Event.Reconnecting, listener: Call.Listener.Reconnecting): this;
    addListener(reconnectedEvent: Call.Event.Reconnected, listener: Call.Listener.Reconnected): this;
    addListener(disconnectedEvent: Call.Event.Disconnected, listener: Call.Listener.Disconnected): this;
    addListener(ringingEvent: Call.Event.Ringing, listener: Call.Listener.Ringing): this;
    addListener(qualityWarningsChangedEvent: Call.Event.QualityWarningsChanged, listener: Call.Listener.QualityWarningsChanged): this;
    addListener(messageReceivedEvent: Call.Event.MessageReceived, listener: Call.Listener.MessageReceived): this;
    addListener(callEvent: Call.Event, listener: Call.Listener.Generic): this;
    // @internal (undocumented)
    emit(connectedEvent: Call.Event.Connected): boolean;
    // @internal (undocumented)
    emit(connectFailureEvent: Call.Event.ConnectFailure, error: TwilioError): boolean;
    // @internal (undocumented)
    emit(reconnectingEvent: Call.Event.Reconnecting, error: TwilioError): boolean;
    // @internal (undocumented)
    emit(reconnectedEvent: Call.Event.Reconnected): boolean;
    // @internal (undocumented)
    emit(disconnectedEvent: Call.Event.Disconnected, error?: TwilioError): boolean;
    // @internal (undocumented)
    emit(ringingEvent: Call.Event.Ringing): boolean;
    // @internal (undocumented)
    emit(qualityWarningsChangedEvent: Call.Event.QualityWarningsChanged, currentQualityWarnings: Call.QualityWarning[], previousQualityWarnings: Call.QualityWarning[]): boolean;
    // @internal (undocumented)
    emit(messageReceivedEvent: Call.Event.MessageReceived, incomingCallMessage: IncomingCallMessage): boolean;
    on(connectedEvent: Call.Event.Connected, listener: Call.Listener.Connected): this;
    on(connectFailureEvent: Call.Event.ConnectFailure, listener: Call.Listener.ConnectFailure): this;
    on(reconnectingEvent: Call.Event.Reconnecting, listener: Call.Listener.Reconnecting): this;
    on(reconnectedEvent: Call.Event.Reconnected, listener: Call.Listener.Reconnected): this;
    on(disconnectedEvent: Call.Event.Disconnected, listener: Call.Listener.Disconnected): this;
    on(ringingEvent: Call.Event.Ringing, listener: Call.Listener.Ringing): this;
    on(qualityWarningsChangedEvent: Call.Event.QualityWarningsChanged, listener: Call.Listener.QualityWarningsChanged): this;
    on(callMessageEvent: Call.Event.MessageReceived, listener: Call.Listener.MessageReceived): this;
    on(callEvent: Call.Event, listener: Call.Listener.Generic): this;
}

// @public
export class Call extends EventEmitter {
    // Warning: (ae-forgotten-export) The symbol "NativeCallInfo" needs to be exported by the entry point index.d.ts
    //
    // @internal
    constructor({ uuid, customParameters, from, sid, state, to, isMuted, isOnHold, initialConnectedTimestamp, }: NativeCallInfo);
    disconnect(): Promise<void>;
    getCustomParameters(): CustomParameters;
    getFrom(): string | undefined;
    getInitialConnectedTimestamp(): Date | undefined;
    getSid(): string | undefined;
    getState(): Call.State;
    getStats(): Promise<RTCStats.StatsReport>;
    getTo(): string | undefined;
    hold(hold: boolean): Promise<boolean>;
    isMuted(): boolean | undefined;
    isOnHold(): boolean | undefined;
    mute(mute: boolean): Promise<boolean>;
    postFeedback(score: Call.Score, issue: Call.Issue): Promise<void>;
    sendDigits(digits: string): Promise<void>;
    sendMessage(message: CallMessage): Promise<OutgoingCallMessage>;
}

// @public
export namespace Call {
    export enum Event {
        'Connected' = "connected",
        'ConnectFailure' = "connectFailure",
        'Disconnected' = "disconnected",
        'MessageReceived' = "messageReceived",
        'QualityWarningsChanged' = "qualityWarningsChanged",
        'Reconnected' = "reconnected",
        'Reconnecting' = "reconnecting",
        'Ringing' = "ringing"
    }
    export enum Issue {
        'AudioLatency' = "audio-latency",
        'ChoppyAudio' = "choppy-audio",
        'DroppedCall' = "dropped-call",
        'Echo' = "echo",
        'NoisyCall' = "noisy-call",
        'NotReported' = "not-reported",
        'OneWayAudio' = "one-way-audio"
    }
    export namespace Listener {
        export type Connected = () => void;
        export type ConnectFailure = (error: TwilioError) => void;
        export type Disconnected = (error?: TwilioError) => void;
        export type Generic = (...args: any[]) => void;
        export type MessageReceived = (incomingCallMessage: IncomingCallMessage) => void;
        export type QualityWarningsChanged = (currentQualityWarnings: Call.QualityWarning[], previousQualityWarnings: Call.QualityWarning[]) => void;
        export type Reconnected = () => void;
        export type Reconnecting = (error: TwilioError) => void;
        export type Ringing = () => void;
    }
    export enum QualityWarning {
        'ConstantAudioInputLevel' = "constant-audio-input-level",
        'HighJitter' = "high-jitter",
        'HighPacketLoss' = "high-packet-loss",
        'HighRtt' = "high-rtt",
        'LowMos' = "low-mos"
    }
    export enum Score {
        'Five' = 5,
        'Four' = 4,
        'NotReported' = 0,
        'One' = 1,
        'Three' = 3,
        'Two' = 2
    }
    export enum State {
        'Connected' = "connected",
        'Connecting' = "connecting",
        'Disconnected' = "disconnected",
        'Reconnecting' = "reconnecting",
        'Ringing' = "ringing"
    }
}

// @public
export interface CallInvite {
    addListener(acceptedEvent: CallInvite.Event.Accepted, listener: CallInvite.Listener.Accepted): this;
    addListener(rejectedEvent: CallInvite.Event.Rejected, listener: CallInvite.Listener.Rejected): this;
    addListener(cancelledEvent: CallInvite.Event.Cancelled, listener: CallInvite.Listener.Cancelled): this;
    addListener(notificationTappedEvent: CallInvite.Event.NotificationTapped, listener: CallInvite.Listener.NotificationTapped): this;
    addListener(messageReceivedEvent: CallInvite.Event.MessageReceived, listener: CallInvite.Listener.MessageReceived): this;
    // @internal (undocumented)
    emit(acceptedEvent: CallInvite.Event.Accepted, call: Call): boolean;
    // @internal (undocumented)
    emit(rejectedEvent: CallInvite.Event.Rejected): boolean;
    // @internal (undocumented)
    emit(cancelledEvent: CallInvite.Event.Cancelled, error?: TwilioError): boolean;
    // @internal (undocumented)
    emit(notificationTappedEvent: CallInvite.Event.NotificationTapped): boolean;
    // @internal (undocumented)
    emit(messageReceivedEvent: CallInvite.Event.MessageReceived, incomingCallMessage: IncomingCallMessage): boolean;
    on(acceptedEvent: CallInvite.Event.Accepted, listener: CallInvite.Listener.Accepted): this;
    on(rejectedEvent: CallInvite.Event.Rejected, listener: CallInvite.Listener.Rejected): this;
    on(cancelledEvent: CallInvite.Event.Cancelled, listener: CallInvite.Listener.Cancelled): this;
    on(notificationTappedEvent: CallInvite.Event.NotificationTapped, listener: CallInvite.Listener.NotificationTapped): this;
    on(messageReceivedEvent: CallInvite.Event.MessageReceived, listener: CallInvite.Listener.MessageReceived): this;
}

// @public
export class CallInvite extends EventEmitter {
    // Warning: (ae-forgotten-export) The symbol "NativeCallInviteInfo" needs to be exported by the entry point index.d.ts
    //
    // @internal
    constructor({ uuid, callSid, customParameters, from, to }: NativeCallInviteInfo, state: CallInvite.State);
    accept(options?: CallInvite.AcceptOptions): Promise<Call>;
    getCallSid(): string;
    getCustomParameters(): CustomParameters;
    getFrom(): string;
    getState(): CallInvite.State;
    getTo(): string;
    // @alpha
    isValid(): Promise<boolean>;
    reject(): Promise<void>;
    sendMessage(message: CallMessage): Promise<OutgoingCallMessage>;
    updateCallerHandle(newHandle: string): Promise<void>;
}

// @public
export namespace CallInvite {
    export interface AcceptOptions {
    }
    export enum Event {
        Accepted = "accepted",
        Cancelled = "cancelled",
        MessageReceived = "messageReceived",
        NotificationTapped = "notificationTapped",
        Rejected = "rejected"
    }
    export namespace Listener {
        export type Accepted = (call: Call) => void;
        export type Cancelled = (error?: TwilioError) => void;
        export type MessageReceived = (incomingCallMessage: IncomingCallMessage) => void;
        export type NotificationTapped = () => void;
        export type Rejected = () => void;
    }
    export enum State {
        Accepted = "accepted",
        Cancelled = "cancelled",
        Pending = "pending",
        Rejected = "rejected"
    }
}

// @public
export namespace CallKit {
    export type ConfigurationOptions = {
        callKitIconTemplateImageData: string;
        callKitIncludesCallsInRecents: boolean;
        callKitMaximumCallGroups: number;
        callKitMaximumCallsPerCallGroup: number;
        callKitRingtoneSound: string;
        callKitSupportedHandleTypes: HandleType[];
    };
    export enum HandleType {
        EmailAddress = 2,
        Generic = 0,
        PhoneNumber = 1
    }
}

// @public
export interface CallMessage {
    content: any;
    contentType?: string;
    messageType: string;
}

// @public
namespace ClientErrors {
    class AddressIncomplete extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class BadRequest extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class BusyHere extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class CallTransactionDoesNotExist extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class Conflict extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class Forbidden extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class NotFound extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class RequestTerminated extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class RequestTimeout extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class TemporarilyUnavailable extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class TooManyRequests extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class UpgradeRequired extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
}

// @public
export type CustomParameters = Record<string, string>;

// @public
namespace ForbiddenErrors {
    class Forbidden extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
}

// @public
namespace GeneralErrors {
    class CallCancelledError extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class ConnectionError extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class TransportError extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
}

// @public (undocumented)
type IceServer = Partial<{
    [Constants.IceServerKeyPassword]: string;
    [Constants.IceServerKeyServerUrl]: string;
    [Constants.IceServerKeyUsername]: string;
}>;

// @public (undocumented)
enum IceTransportPolicy {
    // (undocumented)
    All = "all",
    // (undocumented)
    Relay = "relay"
}

// @public
export class IncomingCallMessage extends EventEmitter {
    // Warning: (ae-forgotten-export) The symbol "NativeCallMessageInfo" needs to be exported by the entry point index.d.ts
    //
    // @internal
    constructor(callMessageInfo: NativeCallMessageInfo);
    getContent(): any;
    getContentType(): string;
    getMessageType(): string;
    getSid(): string | undefined;
}

// @public
class InvalidArgumentError extends TwilioError {
    constructor(message: string);
    // (undocumented)
    description: string;
    // (undocumented)
    explanation: string;
}

// @public
class InvalidStateError extends TwilioError {
    constructor(message: string);
    // (undocumented)
    description: string;
    // (undocumented)
    explanation: string;
}

// @public
namespace MalformedRequestErrors {
    class MalformedRequestError extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
}

// @public
namespace MediaErrors {
    class ClientLocalDescFailed extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class ClientRemoteDescFailed extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class ConnectionError extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class MediaDtlsTransportFailedError extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class NoSupportedCodec extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class ServerLocalDescFailed extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class ServerRemoteDescFailed extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
}

// @public (undocumented)
type OpusAudioCodec = {
    [Constants.AudioCodecKeyType]: Constants.AudioCodecTypeValueOpus;
    [Constants.AudioCodecOpusKeyMaxAverageBitrate]?: number;
};

// @public
export interface OutgoingCallMessage {
    addListener(failureEvent: OutgoingCallMessage.Event.Failure, listener: OutgoingCallMessage.Listener.Failure): this;
    addListener(sentEvent: OutgoingCallMessage.Event.Sent, listener: OutgoingCallMessage.Listener.Sent): this;
    addListener(outgoingCallMessageEvent: OutgoingCallMessage.Event, listener: OutgoingCallMessage.Listener.Generic): this;
    // @internal (undocumented)
    emit(failureEvent: OutgoingCallMessage.Event.Failure, error: TwilioError): boolean;
    // @internal (undocumented)
    emit(sentEvent: OutgoingCallMessage.Event.Sent): boolean;
    on(failureEvent: OutgoingCallMessage.Event.Failure, listener: OutgoingCallMessage.Listener.Failure): this;
    on(sentEvent: OutgoingCallMessage.Event.Sent, listener: OutgoingCallMessage.Listener.Sent): this;
    on(outgoingCallMessageEvent: OutgoingCallMessage.Event, listener: OutgoingCallMessage.Listener.Generic): this;
}

// @public
export class OutgoingCallMessage extends IncomingCallMessage {
    constructor({ content, contentType, messageType, voiceEventSid, }: NativeCallMessageInfo);
}

// @public
export namespace OutgoingCallMessage {
    export enum Event {
        'Failure' = "failure",
        'Sent' = "sent"
    }
    export namespace Listener {
        export type Failure = (error: TwilioError) => void;
        export type Generic = (...args: any[]) => void;
        export type Sent = () => void;
    }
}

// @public (undocumented)
type PCMUAudioCodec = {
    [Constants.AudioCodecKeyType]: Constants.AudioCodecTypeValuePCMU;
};

// @public (undocumented)
export interface PreflightTest {
    addListener(connectedEvent: PreflightTest.Event.Connected, listener: PreflightTest.Listener.Connected): this;
    addListener(completedEvent: PreflightTest.Event.Completed, listener: PreflightTest.Listener.Completed): this;
    addListener(failedEvent: PreflightTest.Event.Failed, listener: PreflightTest.Listener.Failed): this;
    addListener(sampleEvent: PreflightTest.Event.Sample, listener: PreflightTest.Listener.Sample): this;
    addListener(warningEvent: PreflightTest.Event.QualityWarning, listener: PreflightTest.Listener.QualityWarning): this;
    addListener(event: PreflightTest.Event, listener: PreflightTest.Listener.Generic): this;
    // @internal (undocumented)
    emit(connectedEvent: PreflightTest.Event.Connected): boolean;
    // @internal (undocumented)
    emit(completedEvent: PreflightTest.Event.Completed, report: PreflightTest.Report): boolean;
    // @internal (undocumented)
    emit(failedEvent: PreflightTest.Event.Failed, error: TwilioError): boolean;
    // @internal (undocumented)
    emit(sampleEvent: PreflightTest.Event.Sample, sample: PreflightTest.RTCSample): boolean;
    // @internal (undocumented)
    emit(qualityWarningEvent: PreflightTest.Event.QualityWarning, currentWarnings: Call.QualityWarning[], previousWarnings: Call.QualityWarning[]): boolean;
    on(connectedEvent: PreflightTest.Event.Connected, listener: PreflightTest.Listener.Connected): this;
    on(completedEvent: PreflightTest.Event.Completed, listener: PreflightTest.Listener.Completed): this;
    on(failedEvent: PreflightTest.Event.Failed, listener: PreflightTest.Listener.Failed): this;
    on(sampleEvent: PreflightTest.Event.Sample, listener: PreflightTest.Listener.Sample): this;
    on(warningEvent: PreflightTest.Event.QualityWarning, listener: PreflightTest.Listener.QualityWarning): this;
    on(event: PreflightTest.Event, listener: PreflightTest.Listener.Generic): this;
}

// @public
export class PreflightTest extends EventEmitter {
    // @internal
    constructor(uuid: string);
    getCallSid(): Promise<string>;
    getEndTime(): Promise<number>;
    getLatestSample(): Promise<PreflightTest.RTCSample>;
    getReport(): Promise<PreflightTest.Report>;
    getStartTime(): Promise<number>;
    getState(): Promise<PreflightTest.State>;
}

// @public
export namespace PreflightTest {
    // (undocumented)
    export enum CallQuality {
        // (undocumented)
        Degraded = "Degraded",
        // (undocumented)
        Excellent = "Excellent",
        // (undocumented)
        Fair = "Fair",
        // (undocumented)
        Good = "Good",
        // (undocumented)
        Great = "Great"
    }
    export enum Event {
        Completed = "completed",
        Connected = "connected",
        Failed = "failed",
        QualityWarning = "qualityWarning",
        Sample = "sample"
    }
    export namespace Listener {
        export type Completed = (report: Report) => void;
        export type Connected = () => void;
        export type Failed = (error: TwilioError) => void;
        export type Generic = (...args: any[]) => void;
        export type QualityWarning = (currentWarnings: Call.QualityWarning[], previousWarnings: Call.QualityWarning[]) => void;
        export type Sample = (sample: RTCSample) => void;
    }
    // (undocumented)
    export interface NetworkTiming {
        // (undocumented)
        [Constants.PreflightNetworkTimingIce]: TimeMeasurement;
        // (undocumented)
        [Constants.PreflightNetworkTimingPeerConnection]: TimeMeasurement;
        // (undocumented)
        [Constants.PreflightNetworkTimingSignaling]: TimeMeasurement;
    }
    export interface Options {
        // Warning: (ae-forgotten-export) The symbol "CallOptionsType" needs to be exported by the entry point index.d.ts
        [Constants.CallOptionsKeyIceServers]?: CallOptionsType.IceServer[];
        [Constants.CallOptionsKeyIceTransportPolicy]?: CallOptionsType.IceTransportPolicy;
        [Constants.CallOptionsKeyPreferredAudioCodecs]?: CallOptionsType.AudioCodec;
    }
    // (undocumented)
    export interface Report {
        // (undocumented)
        [Constants.PreflightReportCallQuality]?: CallQuality;
        // (undocumented)
        [Constants.PreflightReportCallSid]: string;
        // (undocumented)
        [Constants.PreflightReportEdge]: string;
        // (undocumented)
        [Constants.PreflightReportIceCandidateStats]: RTCIceCandidateStats[];
        // (undocumented)
        [Constants.PreflightReportIsTurnRequired]: boolean | null;
        // (undocumented)
        [Constants.PreflightReportNetworkTiming]: NetworkTiming;
        // (undocumented)
        [Constants.PreflightReportSamples]: RTCSample[];
        // (undocumented)
        [Constants.PreflightReportSelectedEdge]: string;
        // (undocumented)
        [Constants.PreflightReportSelectedIceCandidatePairStats]: RTCSelectedIceCandidatePairStats;
        // (undocumented)
        [Constants.PreflightReportStats]: RTCStats;
        // (undocumented)
        [Constants.PreflightReportTestTiming]: TimeMeasurement;
        // (undocumented)
        [Constants.PreflightReportWarnings]: Warning[];
        // (undocumented)
        [Constants.PreflightReportWarningsCleared]: WarningCleared[];
    }
    // (undocumented)
    export interface RTCIceCandidateStats {
        // (undocumented)
        [Constants.PreflightRTCIceCandidateStatsCandidateType]: string;
        // (undocumented)
        [Constants.PreflightRTCIceCandidateStatsDeleted]: boolean;
        // (undocumented)
        [Constants.PreflightRTCIceCandidateStatsIp]: string;
        // (undocumented)
        [Constants.PreflightRTCIceCandidateStatsIsRemote]: boolean;
        // (undocumented)
        [Constants.PreflightRTCIceCandidateStatsNetworkCost]: number;
        // (undocumented)
        [Constants.PreflightRTCIceCandidateStatsNetworkId]: number;
        // (undocumented)
        [Constants.PreflightRTCIceCandidateStatsNetworkType]: string;
        // (undocumented)
        [Constants.PreflightRTCIceCandidateStatsPort]: number;
        // (undocumented)
        [Constants.PreflightRTCIceCandidateStatsProtocol]: string;
        // (undocumented)
        [Constants.PreflightRTCIceCandidateStatsRelatedAddress]: string;
        // (undocumented)
        [Constants.PreflightRTCIceCandidateStatsRelatedPort]: number;
        // (undocumented)
        [Constants.PreflightRTCIceCandidateStatsTcpType]: string;
        // (undocumented)
        [Constants.PreflightRTCIceCandidateStatsTransportId]: string;
        // (undocumented)
        [Constants.PreflightRTCIceCandidateStatsUrl]: string;
    }
    // (undocumented)
    export interface RTCSample {
        // (undocumented)
        [Constants.PreflightRTCSampleAudioInputLevel]: number;
        // (undocumented)
        [Constants.PreflightRTCSampleAudioOutputLevel]: number;
        // (undocumented)
        [Constants.PreflightRTCSampleBytesReceived]: number;
        // (undocumented)
        [Constants.PreflightRTCSampleBytesSent]: number;
        // (undocumented)
        [Constants.PreflightRTCSampleCodec]: string;
        // (undocumented)
        [Constants.PreflightRTCSampleJitter]: number;
        // (undocumented)
        [Constants.PreflightRTCSampleMos]: number;
        // (undocumented)
        [Constants.PreflightRTCSamplePacketsLost]: number;
        // (undocumented)
        [Constants.PreflightRTCSamplePacketsLostFraction]: number;
        // (undocumented)
        [Constants.PreflightRTCSamplePacketsReceived]: number;
        // (undocumented)
        [Constants.PreflightRTCSamplePacketsSent]: number;
        // (undocumented)
        [Constants.PreflightRTCSampleRtt]: number;
        // (undocumented)
        [Constants.PreflightRTCSampleTimestamp]: string;
    }
    // (undocumented)
    export interface RTCSelectedIceCandidatePairStats {
        // (undocumented)
        [Constants.PreflightRTCSelectedIceCandidatePairStatsLocalCandidate]: RTCIceCandidateStats;
        // (undocumented)
        [Constants.PreflightRTCSelectedIceCandidatePairStatsRemoteCandidate]: RTCIceCandidateStats;
    }
    // (undocumented)
    export interface RTCStats {
        // (undocumented)
        [Constants.PreflightRTCStatsJitter]: Stats;
        // (undocumented)
        [Constants.PreflightRTCStatsMos]: Stats;
        // (undocumented)
        [Constants.PreflightRTCStatsRtt]: Stats;
    }
    export enum State {
        Completed = "completed",
        Connected = "connected",
        Connecting = "connecting",
        Failed = "failed"
    }
    // (undocumented)
    export interface Stats {
        // (undocumented)
        [Constants.PreflightStatsAverage]: number;
        // (undocumented)
        [Constants.PreflightStatsMax]: number;
        // (undocumented)
        [Constants.PreflightStatsMin]: number;
    }
    // (undocumented)
    export interface TimeMeasurement {
        // (undocumented)
        [Constants.PreflightTimeMeasurementDuration]: number;
        // (undocumented)
        [Constants.PreflightTimeMeasurementEnd]: number;
        // (undocumented)
        [Constants.PreflightTimeMeasurementStart]: number;
    }
    // (undocumented)
    export interface Warning {
        // (undocumented)
        [Constants.PreflightWarningName]: string;
        // (undocumented)
        [Constants.PreflightWarningThreshold]: string;
        // (undocumented)
        [Constants.PreflightWarningTimestamp]: number;
        // (undocumented)
        [Constants.PreflightWarningValues]: string;
    }
    // (undocumented)
    export interface WarningCleared {
        // (undocumented)
        [Constants.PreflightWarningClearedName]: string;
        // (undocumented)
        [Constants.PreflightWarningClearedTimestamp]: number;
    }
}

// @public
namespace RegistrationErrors {
    class RegistrationError extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        // (undocumented)
        explanation: string;
        name: string;
        solutions: string[];
    }
    class UnsupportedCancelMessageError extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
}

// @public
export namespace RTCStats {
    // (undocumented)
    export interface BaseTrackStats {
        // (undocumented)
        codec: string;
        // (undocumented)
        packetsLost: number;
        // (undocumented)
        ssrc: string;
        // (undocumented)
        timestamp: number;
        // (undocumented)
        trackId: string;
    }
    // (undocumented)
    export enum IceCandidatePairState {
        // (undocumented)
        STATE_FAILED = "STATE_FAILED",
        // (undocumented)
        STATE_FROZEN = "STATE_FROZEN",
        // (undocumented)
        STATE_IN_PROGRESS = "STATE_IN_PROGRESS",
        // (undocumented)
        STATE_SUCCEEDED = "STATE_SUCCEEDED",
        // (undocumented)
        STATE_WAITING = "STATE_WAITING"
    }
    // (undocumented)
    export interface IceCandidatePairStats {
        // (undocumented)
        activeCandidatePair: boolean;
        // (undocumented)
        availableIncomingBitrate: number;
        // (undocumented)
        availableOutgoingBitrate: number;
        // (undocumented)
        bytesReceived: number;
        // (undocumented)
        bytesSent: number;
        // (undocumented)
        consentRequestsReceived: number;
        // (undocumented)
        consentRequestsSent: number;
        // (undocumented)
        consentResponsesReceived: number;
        // (undocumented)
        consentResponsesSent: number;
        // (undocumented)
        currentRoundTripTime: number;
        // (undocumented)
        localCandidateId: string;
        // (undocumented)
        localCandidateIp: string;
        // (undocumented)
        nominated: boolean;
        // (undocumented)
        priority: number;
        // (undocumented)
        readable: boolean;
        // (undocumented)
        relayProtocol: string;
        // (undocumented)
        remoteCandidateId: string;
        // (undocumented)
        remoteCandidateIp: string;
        // (undocumented)
        requestsReceieved: number;
        // (undocumented)
        requestsSent: number;
        // (undocumented)
        responsesRecieved: number;
        // (undocumented)
        responsesSent: number;
        // (undocumented)
        retransmissionsReceived: number;
        // (undocumented)
        retransmissionsSent: number;
        // (undocumented)
        state: IceCandidatePairState;
        // (undocumented)
        totalRoundTripTime: number;
        // (undocumented)
        transportId: string;
        // (undocumented)
        writeable: boolean;
    }
    // (undocumented)
    export interface IceCandidateStats {
        // (undocumented)
        candidateType: string;
        // (undocumented)
        deleted: boolean;
        // (undocumented)
        ip: string;
        // (undocumented)
        isRemote: boolean;
        // (undocumented)
        port: number;
        // (undocumented)
        priority: number;
        // (undocumented)
        protocol: string;
        // (undocumented)
        transportId: string;
        // (undocumented)
        url: string;
    }
    // (undocumented)
    export interface LocalAudioTrackStats extends LocalTrackStats {
        // (undocumented)
        audioLevel: number;
        // (undocumented)
        jitter: number;
    }
    // (undocumented)
    export interface LocalTrackStats extends BaseTrackStats {
        // (undocumented)
        bytesSent: number;
        // (undocumented)
        packetsSent: number;
        // (undocumented)
        roundTripTime: number;
    }
    // (undocumented)
    export interface RemoteAudioTrackStats extends RemoteTrackStats {
        // (undocumented)
        audioLevel: number;
        // (undocumented)
        jitter: number;
        // (undocumented)
        mos: number;
    }
    // (undocumented)
    export interface RemoteTrackStats extends BaseTrackStats {
        // (undocumented)
        bytesRecieved: number;
        // (undocumented)
        packetsReceived: number;
    }
    export interface StatsReport {
        // (undocumented)
        iceCandidatePairStats: IceCandidatePairStats[];
        // (undocumented)
        iceCandidateStats: IceCandidateStats[];
        // (undocumented)
        localAudioTrackStats: LocalAudioTrackStats[];
        // (undocumented)
        peerConnectionId: string;
        // (undocumented)
        remoteAudioTrackStats: RemoteAudioTrackStats[];
    }
}

// @public
namespace ServerErrors {
    class BadGateway extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class DNSResolutionError extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class GatewayTimeout extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class InternalServerError extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class ServiceUnavailable extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
}

// @public
namespace SignalingErrors {
    class ConnectionDisconnected extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
}

// @public
namespace SIPServerErrors {
    class BusyEverywhere extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class Decline extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
    class DoesNotExistAnywhere extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
}

// @public
class TwilioError extends Error {
    constructor(message: string, code?: number);
    // (undocumented)
    causes: string[];
    // (undocumented)
    code: number | undefined;
    // (undocumented)
    description: string;
    // (undocumented)
    explanation: string;
    // (undocumented)
    solutions: string[];
}

declare namespace TwilioErrors {
    export {
        InvalidArgumentError,
        InvalidStateError,
        UnsupportedPlatformError,
        TwilioError,
        AuthorizationErrors,
        ClientErrors,
        ForbiddenErrors,
        GeneralErrors,
        MalformedRequestErrors,
        MediaErrors,
        RegistrationErrors,
        ServerErrors,
        SignalingErrors,
        SIPServerErrors,
        TwiMLErrors,
        UserMediaErrors
    }
}
export { TwilioErrors }

// @public
namespace TwiMLErrors {
    class InvalidApplicationSid extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
}

// @public
class UnsupportedPlatformError extends TwilioError {
    constructor(message: string);
    // (undocumented)
    description: string;
    // (undocumented)
    explanation: string;
}

// @public
namespace UserMediaErrors {
    class PermissionDeniedError extends TwilioError {
        constructor(message: string);
        causes: string[];
        description: string;
        explanation: string;
        name: string;
        solutions: string[];
    }
}

// @public
export interface Voice {
    addListener(audioDevicesUpdatedEvent: Voice.Event.AudioDevicesUpdated, listener: Voice.Listener.AudioDevicesUpdated): this;
    addListener(callInviteEvent: Voice.Event.CallInvite, listener: Voice.Listener.CallInvite): this;
    addListener(errorEvent: Voice.Event.Error, listener: Voice.Listener.Error): this;
    addListener(registeredEvent: Voice.Event.Registered, listener: Voice.Listener.Registered): this;
    addListener(unregisteredEvent: Voice.Event.Unregistered, listener: Voice.Listener.Unregistered): this;
    addListener(voiceEvent: Voice.Event, listener: Voice.Listener.Generic): this;
    // @internal (undocumented)
    emit(voiceEvent: Voice.Event.AudioDevicesUpdated, audioDevices: AudioDevice[], selectedDevice?: AudioDevice): boolean;
    // @internal (undocumented)
    emit(voiceEvent: Voice.Event.CallInvite, callInvite: CallInvite): boolean;
    // @internal (undocumented)
    emit(voiceEvent: Voice.Event.Error, error: TwilioError): boolean;
    // @internal (undocumented)
    emit(voiceEvent: Voice.Event.Registered): boolean;
    // @internal (undocumented)
    emit(voiceEvent: Voice.Event.Unregistered): boolean;
    // @internal (undocumented)
    emit(voiceEvent: Voice.Event, ...args: any[]): boolean;
    on(audioDevicesUpdatedEvent: Voice.Event.AudioDevicesUpdated, listener: Voice.Listener.AudioDevicesUpdated): this;
    on(callInviteEvent: Voice.Event.CallInvite, listener: Voice.Listener.CallInvite): this;
    on(errorEvent: Voice.Event.Error, listener: Voice.Listener.Error): this;
    on(registeredEvent: Voice.Event.Registered, listener: Voice.Listener.Registered): this;
    on(unregisteredEvent: Voice.Event.Unregistered, listener: Voice.Listener.Unregistered): this;
    on(voiceEvent: Voice.Event, listener: Voice.Listener.Generic): this;
}

// @public
export class Voice extends EventEmitter {
    constructor();
    connect(token: string, { contactHandle, notificationDisplayName, params, }?: Voice.ConnectOptions): Promise<Call>;
    getAudioDevices(): Promise<{
        audioDevices: AudioDevice[];
        selectedDevice?: AudioDevice;
    }>;
    getCallInvites(): Promise<ReadonlyMap<Uuid, CallInvite>>;
    getCalls(): Promise<ReadonlyMap<Uuid, Call>>;
    getDeviceToken(): Promise<string>;
    getVersion(): Promise<string>;
    handleFirebaseMessage(remoteMessage: Record<string, string>): Promise<boolean>;
    initializePushRegistry(): Promise<void>;
    isFullScreenNotificationEnabled(): Promise<boolean>;
    register(token: string): Promise<void>;
    requestFullScreenNotificationPermission(): Promise<void>;
    runPreflight(accessToken: string, options?: PreflightTest.Options): Promise<PreflightTest>;
    setCallKitConfiguration(configuration: CallKit.ConfigurationOptions): Promise<void>;
    setIncomingCallContactHandleTemplate(template?: string): Promise<void>;
    showAvRoutePickerView(): Promise<void>;
    unregister(token: string): Promise<void>;
}

// @public
export namespace Voice {
    export type ConnectOptions = {
        params?: Record<string, string>;
        contactHandle?: string;
        notificationDisplayName?: string;
    };
    export enum Event {
        'AudioDevicesUpdated' = "audioDevicesUpdated",
        'CallInvite' = "callInvite",
        'Error' = "error",
        'Registered' = "registered",
        'Unregistered' = "unregistered"
    }
    export namespace Listener {
        export type AudioDevicesUpdated = (audioDevices: AudioDevice[], selectedDevice?: AudioDevice) => void;
        export type CallInvite = (callInvite: CallInvite) => void;
        export type Error = (error: TwilioError) => void;
        export type Generic = (...args: any[]) => void;
        export type Registered = () => void;
        export type Unregistered = () => void;
    }
}

// Warnings were encountered during analysis:
//
// lib/typescript/type/CallOptions.d.ts:7:5 - (ae-forgotten-export) The symbol "Constants" needs to be exported by the entry point index.d.ts

```
