## API Report File for "@twilio/voice-react-native-sdk"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { EventEmitter } from 'eventemitter3';

// @public
export class AudioDevice {
    // Warning: (ae-forgotten-export) The symbol "NativeAudioDeviceInfo" needs to be exported by the entry point index.d.ts
    //
    // @internal
    constructor({ uuid, type, name }: NativeAudioDeviceInfo);
    name: string;
    select(): Promise<void>;
    type: AudioDevice.Type;
    // Warning: (ae-forgotten-export) The symbol "Uuid" needs to be exported by the entry point index.d.ts
    //
    // @internal
    uuid: Uuid;
}

// @public
export namespace AudioDevice {
    export enum Type {
        // (undocumented)
        Bluetooth = "bluetooth",
        // (undocumented)
        Earpiece = "earpiece",
        // (undocumented)
        Speaker = "speaker"
    }
}

// @public
export interface Call {
    addEventListener(callEvent: Call.Event, listener: Call.Listener.Generic): this;
    addEventListener(connectedEvent: Call.Event.Connected, listener: Call.Listener.Connected): this;
    addEventListener(connectFailureEvent: Call.Event.ConnectFailure, listener: Call.Listener.ConnectFailure): this;
    addEventListener(reconnectingEvent: Call.Event.Reconnecting, listener: Call.Listener.Reconnecting): this;
    addEventListener(reconnectedEvent: Call.Event.Reconnected, listener: Call.Listener.Reconnected): this;
    addEventListener(disconnectedEvent: Call.Event.Disconnected, listener: Call.Listener.Disconnected): this;
    addEventListener(ringingEvent: Call.Event.Ringing, listener: Call.Listener.Ringing): this;
    addEventListener(qualityWarningsChangedEvent: Call.Event.QualityWarningsChanged, listener: Call.Listener.QualityWarningsChanged): this;
    // @internal (undocumented)
    emit(connectedEvent: Call.Event.Connected): boolean;
    // @internal (undocumented)
    emit(connectFailureEvent: Call.Event.ConnectFailure, error: GenericError): boolean;
    // @internal (undocumented)
    emit(reconnectingEvent: Call.Event.Reconnecting, error: GenericError): boolean;
    // @internal (undocumented)
    emit(reconnectedEvent: Call.Event.Reconnected): boolean;
    // @internal (undocumented)
    emit(disconnectedEvent: Call.Event.Disconnected, error?: GenericError): boolean;
    // @internal (undocumented)
    emit(ringingEvent: Call.Event.Ringing): boolean;
    // @internal (undocumented)
    emit(callEvent: Call.Event.QualityWarningsChanged, currentQualityWarnings: Call.QualityWarning[], previousQualityWarnings: Call.QualityWarning[]): boolean;
    on(callEvent: Call.Event, listener: Call.Listener.Generic): this;
    on(connectedEvent: Call.Event.Connected, listener: Call.Listener.Connected): this;
    on(connectFailureEvent: Call.Event.ConnectFailure, listener: Call.Listener.ConnectFailure): this;
    on(reconnectingEvent: Call.Event.Reconnecting, listener: Call.Listener.Reconnecting): this;
    on(reconnectedEvent: Call.Event.Reconnected, listener: Call.Listener.Reconnected): this;
    on(disconnectedEvent: Call.Event.Disconnected, listener: Call.Listener.Disconnected): this;
    on(ringingEvent: Call.Event.Ringing, listener: Call.Listener.Ringing): this;
    on(qualityWarningsChangedEvent: Call.Event.QualityWarningsChanged, listener: Call.Listener.QualityWarningsChanged): this;
}

// @public
export class Call extends EventEmitter {
    // Warning: (ae-forgotten-export) The symbol "NativeCallInfo" needs to be exported by the entry point index.d.ts
    //
    // @internal
    constructor({ uuid, customParameters, from, sid, to, isMuted, isOnHold, }: NativeCallInfo);
    disconnect(): Promise<void>;
    getCustomParameters(): CustomParameters;
    getFrom(): string | undefined;
    getSid(): string | undefined;
    getState(): Call.State;
    getStats(): Promise<RTCStats.StatsReport>;
    getTo(): string | undefined;
    hold(hold: boolean): Promise<boolean>;
    isMuted(): boolean | undefined;
    isOnHold(): boolean | undefined;
    mute(mute: boolean): Promise<boolean>;
    postFeedback(score: Call.Score, issue: Call.Issue): Promise<void>;
    sendDigits(digits: string): Promise<void>;
}

// @public
export namespace Call {
    export enum Event {
        'Connected' = "connected",
        'ConnectFailure' = "connectFailure",
        'Disconnected' = "disconnected",
        'QualityWarningsChanged' = "qualityWarningsChanged",
        'Reconnected' = "reconnected",
        'Reconnecting' = "reconnecting",
        'Ringing' = "ringing"
    }
    export enum Issue {
        AudioLatency = "audio-latency",
        ChoppyAudio = "choppy-audio",
        DroppedCall = "dropped-call",
        Echo = "echo",
        NoisyCall = "noisy-call",
        NotReported = "not-reported",
        OneWayAudio = "one-way-audio"
    }
    const // Warning: (ae-forgotten-export) The symbol "NativeCallEventType" needs to be exported by the entry point index.d.ts
    //
    // @internal
    EventTypeStateMap: Partial<Record<NativeCallEventType, Call.State>>;
    export namespace Listener {
        export type Connected = () => void;
        export type ConnectFailure = (error: GenericError) => void;
        export type Disconnected = (error?: GenericError) => void;
        export type Generic = (...args: any[]) => void;
        export type QualityWarningsChanged = (currentQualityWarnings: Call.QualityWarning[], previousQualityWarnings: Call.QualityWarning[]) => void;
        export type Reconnected = () => void;
        export type Reconnecting = (error: GenericError) => void;
        export type Ringing = () => void;
    }
    export enum QualityWarning {
        ConstantAudioInputLevel = "constant-audio-input-level",
        HighJitter = "high-jitter",
        HighPacketLoss = "high-packet-loss",
        HighRtt = "high-rtt",
        LowMos = "low-mos"
    }
    export enum Score {
        Five = 5,
        Four = 4,
        NotReported = 0,
        One = 1,
        Three = 3,
        Two = 2
    }
    export enum State {
        'Connected' = "connected",
        'Connecting' = "connecting",
        'Disconnected' = "disconnected",
        'Reconnecting' = "reconnected",
        'Ringing' = "ringing"
    }
}

// @public
export class CallInvite {
    // Warning: (ae-forgotten-export) The symbol "NativeCallInviteInfo" needs to be exported by the entry point index.d.ts
    //
    // @internal
    constructor({ uuid, callSid, customParameters, from, to }: NativeCallInviteInfo, state: CallInvite.State);
    accept(options?: CallInvite.AcceptOptions): Promise<Call>;
    getCallSid(): string;
    getCustomParameters(): CustomParameters;
    getFrom(): string;
    getState(): CallInvite.State;
    getTo(): string;
    // @alpha
    isValid(): Promise<boolean>;
    reject(): Promise<void>;
}

// @public
export namespace CallInvite {
    export interface AcceptOptions {
    }
    export enum State {
        // (undocumented)
        Accepted = "accepted",
        // (undocumented)
        Pending = "pending",
        // (undocumented)
        Rejected = "rejected"
    }
}

// @public
export class CancelledCallInvite {
    // Warning: (ae-forgotten-export) The symbol "NativeCancelledCallInviteInfo" needs to be exported by the entry point index.d.ts
    //
    // @internal
    constructor({ callSid, from, to }: NativeCancelledCallInviteInfo);
    getCallSid(): string;
    getFrom(): string;
    getTo(): string;
}

// @public
export type CustomParameters = Record<string, any>;

// @public
class GenericError extends Error {
    constructor(message: string, code?: number);
    // (undocumented)
    code: number | undefined;
}

// @public
class InvalidStateError extends GenericError {
    constructor(message: string);
}

// @public
export namespace RTCStats {
    // (undocumented)
    export interface BaseTrackStats {
        // (undocumented)
        codec: string;
        // (undocumented)
        packetsLost: number;
        // (undocumented)
        ssrc: string;
        // (undocumented)
        timestamp: number;
        // (undocumented)
        trackId: string;
    }
    // (undocumented)
    export enum IceCandidatePairState {
        // (undocumented)
        STATE_FAILED = "STATE_FAILED",
        // (undocumented)
        STATE_FROZEN = "STATE_FROZEN",
        // (undocumented)
        STATE_IN_PROGRESS = "STATE_IN_PROGRESS",
        // (undocumented)
        STATE_SUCCEEDED = "STATE_SUCCEEDED",
        // (undocumented)
        STATE_WAITING = "STATE_WAITING"
    }
    // (undocumented)
    export interface IceCandidatePairStats {
        // (undocumented)
        activeCandidatePair: boolean;
        // (undocumented)
        availableIncomingBitrate: number;
        // (undocumented)
        availableOutgoingBitrate: number;
        // (undocumented)
        bytesReceived: number;
        // (undocumented)
        bytesSent: number;
        // (undocumented)
        consentRequestsReceived: number;
        // (undocumented)
        consentRequestsSent: number;
        // (undocumented)
        consentResponsesReceived: number;
        // (undocumented)
        consentResponsesSent: number;
        // (undocumented)
        currentRoundTripTime: number;
        // (undocumented)
        localCandidateId: string;
        // (undocumented)
        localCandidateIp: string;
        // (undocumented)
        nominated: boolean;
        // (undocumented)
        priority: number;
        // (undocumented)
        readable: boolean;
        // (undocumented)
        relayProtocol: string;
        // (undocumented)
        remoteCandidateId: string;
        // (undocumented)
        remoteCandidateIp: string;
        // (undocumented)
        requestsReceieved: number;
        // (undocumented)
        requestsSent: number;
        // (undocumented)
        responsesRecieved: number;
        // (undocumented)
        responsesSent: number;
        // (undocumented)
        retransmissionsReceived: number;
        // (undocumented)
        retransmissionsSent: number;
        // (undocumented)
        state: IceCandidatePairState;
        // (undocumented)
        totalRoundTripTime: number;
        // (undocumented)
        transportId: string;
        // (undocumented)
        writeable: boolean;
    }
    // (undocumented)
    export interface IceCandidateStats {
        // (undocumented)
        candidateType: string;
        // (undocumented)
        deleted: boolean;
        // (undocumented)
        ip: string;
        // (undocumented)
        isRemote: boolean;
        // (undocumented)
        port: number;
        // (undocumented)
        priority: number;
        // (undocumented)
        protocol: string;
        // (undocumented)
        transportId: string;
        // (undocumented)
        url: string;
    }
    // (undocumented)
    export interface LocalAudioTrackStats extends LocalTrackStats {
        // (undocumented)
        audioLevel: number;
        // (undocumented)
        jitter: number;
    }
    // (undocumented)
    export interface LocalTrackStats extends BaseTrackStats {
        // (undocumented)
        bytesSent: number;
        // (undocumented)
        packetsSent: number;
        // (undocumented)
        roundTripTime: number;
    }
    // (undocumented)
    export interface RemoteAudioTrackStats extends RemoteTrackStats {
        // (undocumented)
        audioLevel: number;
        // (undocumented)
        jitter: number;
        // (undocumented)
        mos: number;
    }
    // (undocumented)
    export interface RemoteTrackStats extends BaseTrackStats {
        // (undocumented)
        bytesRecieved: number;
        // (undocumented)
        packetsReceived: number;
    }
    export interface StatsReport {
        // (undocumented)
        iceCandidatePairStats: IceCandidatePairStats[];
        // (undocumented)
        iceCandidateStats: IceCandidateStats[];
        // (undocumented)
        localAudioTrackStats: LocalAudioTrackStats[];
        // (undocumented)
        peerConnectionId: string;
        // (undocumented)
        remoteAudioTrackStats: RemoteAudioTrackStats[];
    }
}

declare namespace TwilioErrors {
    export {
        InvalidStateError,
        GenericError
    }
}
export { TwilioErrors }

// @public
export interface Voice {
    addEventListener(voiceEvent: Voice.Event, listener: Voice.Listener.Generic): this;
    addEventListener(audioDevicesUpdatedEvent: Voice.Event.AudioDevicesUpdated, listener: Voice.Listener.AudioDevicesUpdated): this;
    addEventListener(callInviteEvent: Voice.Event.CallInvite, listener: Voice.Listener.CallInvite): this;
    addEventListener(callInviteAcceptedEvent: Voice.Event.CallInviteAccepted, listener: Voice.Listener.CallInviteAccepted): this;
    addEventListener(callInviteRejectedEvent: Voice.Event.CallInviteRejected, listener: Voice.Listener.CallInviteRejected): this;
    addEventListener(cancelledCallInviteEvent: Voice.Event.CancelledCallInvite, listener: Voice.Listener.CancelledCallInvite): this;
    addEventListener(errorEvent: Voice.Event.Error, listener: Voice.Listener.Error): this;
    addEventListener(registeredEvent: Voice.Event.Registered, listener: Voice.Listener.Registered): this;
    addEventListener(unregisteredEvent: Voice.Event.Unregistered, listener: Voice.Listener.Unregistered): this;
    // @internal (undocumented)
    emit(voiceEvent: Voice.Event, listener: (...args: any[]) => void): boolean;
    // @internal (undocumented)
    emit(voiceEvent: Voice.Event.AudioDevicesUpdated, audioDevices: AudioDevice[], selectedDevice: AudioDevice): boolean;
    // @internal (undocumented)
    emit(voiceEvent: Voice.Event.CallInvite, callInvite: CallInvite): boolean;
    // @internal (undocumented)
    emit(voiceEvent: Voice.Event.CallInviteAccepted, callInvite: CallInvite, call: Call): boolean;
    // @internal (undocumented)
    emit(voiceEvent: Voice.Event.CallInviteRejected, callInvite: CallInvite): boolean;
    // @internal (undocumented)
    emit(voiceEvent: Voice.Event.CancelledCallInvite, cancelledCallInvite: CancelledCallInvite, error?: GenericError): boolean;
    // @internal (undocumented)
    emit(voiceEvent: Voice.Event.Error, error: GenericError): boolean;
    // @internal (undocumented)
    emit(voiceEvent: Voice.Event.Registered): boolean;
    // @internal (undocumented)
    emit(voiceEvent: Voice.Event.Unregistered): boolean;
    on(voiceEvent: Voice.Event, listener: Voice.Listener.Generic): this;
    on(audioDevicesUpdatedEvent: Voice.Event.AudioDevicesUpdated, listener: Voice.Listener.AudioDevicesUpdated): this;
    on(callInviteEvent: Voice.Event.CallInvite, listener: Voice.Listener.CallInvite): this;
    on(callInviteAcceptedEvent: Voice.Event.CallInviteAccepted, listener: Voice.Listener.CallInviteAccepted): this;
    on(callInviteRejectedEvent: Voice.Event.CallInviteRejected, listener: Voice.Listener.CallInviteRejected): this;
    on(cancelledCallInviteEvent: Voice.Event.CancelledCallInvite, listener: Voice.Listener.CancelledCallInvite): this;
    on(errorEvent: Voice.Event.Error, listener: Voice.Listener.Error): this;
    on(registeredEvent: Voice.Event.Registered, listener: Voice.Listener.Registered): this;
    on(unregisteredEvent: Voice.Event.Unregistered, listener: Voice.Listener.Unregistered): this;
}

// @public
export class Voice extends EventEmitter {
    constructor();
    connect(token: string, params?: Record<string, any>): Promise<Call>;
    getAudioDevices(): Promise<{
        audioDevices: AudioDevice[];
        selectedDevice: AudioDevice | null;
    }>;
    getCallInvites(): Promise<ReadonlyMap<Uuid, CallInvite>>;
    getCalls(): Promise<ReadonlyMap<Uuid, Call>>;
    getDeviceToken(): Promise<string>;
    getVersion(): Promise<string>;
    register(token: string): Promise<void>;
    showAvRoutePickerView(): Promise<void>;
    unregister(token: string): Promise<void>;
}

// @public
export namespace Voice {
    export enum Event {
        'AudioDevicesUpdated' = "audioDevicesUpdated",
        'CallInvite' = "callInvite",
        'CallInviteAccepted' = "callInviteAccepted",
        'CallInviteRejected' = "callInviteRejected",
        'CancelledCallInvite' = "cancelledCallInvite",
        'Error' = "error",
        'Registered' = "registered",
        'Unregistered' = "unregistered"
    }
    export namespace Listener {
        export type AudioDevicesUpdated = (audioDevices: AudioDevice[], selectedDevice: AudioDevice | null) => void;
        export type CallInvite = (callInvite: CallInvite) => void;
        export type CallInviteAccepted = (callInvite: CallInvite, call: Call) => void;
        export type CallInviteRejected = (callInvite: CallInvite) => void;
        export type CancelledCallInvite = (cancelledCallInvite: CancelledCallInvite, error?: GenericError) => void;
        export type Error = (error: GenericError) => void;
        export type Generic = (...args: any[]) => void;
        export type Registered = () => void;
        export type Unregistered = () => void;
    }
}

```
